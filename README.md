# BFS-for-Black-Nodes
为解决在大规模图上找每个结点二阶邻居内异常点耗时过长的问题，尝试剪枝等优化算法

* BFS.h: 定义了BFS，是最基本的方法，分别对每个点进行深度为2的BFS遍历。预估的算法复杂度为 O(d* d* n)。(d 为每个结点的平均度数)
* heapBFS.h: 定义了创新的方法，是用堆将每个顶点的一阶黑点按序存储。如果要求结点 i 二阶邻居内的黑点数，可以用一个堆合并 i 所有一阶点的有序黑点，预估的算法复杂度为 O(log(d)* d* n)
* createdata.h: 定义了随机设置给定图黑点，并输出到文件中的函数
* main: 测试函数
* data: 包括测试的数据集，存储最后实验结果的数据集 result.txt
* myBFS.h: 尝试实现了自己的方法，但发现要保证其正确性，复杂度将回归到与 BFS 相同，故并没有继续用大数据集实验。将myBFS的方法替换为用hash存储每个点找到的黑点，实验结果见 data/result3.txt
* blackBFS: 一种简单但效果很好的方法，在bfs二阶遍历时，只对每个一阶结点的黑点进行bfs遍历，这样就剪枝掉大量无关的白点，实验测试时间比普通bfs能降低一个数量级，实验结果见 data/result4.txt

在 snap 上选取了四张结点数从 10^3 到 10^5 的图，随机将图中的部分顶点设置为异常点(5% ~ 40%)，实验得到的数据见 data/result.txt
